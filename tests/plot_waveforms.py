#!/usr/bin/env python3
"""Plot Waveforms - A script for visualizing waveforms generated by the Waveform class
and processed by the CoilDriver class.

This script generates random waveforms, applies calibration to get displacement and velocity,
and plots all waveforms and their FFTs.
"""


import matplotlib.pyplot as plt
import numpy as np
from matplotlib import gridspec
from numpy.fft import fft, fftfreq
from scipy import stats

from redpitaya.coil_driver import CoilDriver
from redpitaya.waveform import Waveform


def calculate_fft(
    signal: np.ndarray, sample_rate: float
) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
    """Calculate the FFT of a signal.

    Args:
        signal: Time domain signal
        sample_rate: Sample rate in Hz

    Returns:
        Tuple containing:
        - Frequencies
        - Magnitude of FFT
        - Phase of FFT
    """
    n = len(signal)
    fft_result = fft(signal, norm='ortho')
    freqs = fftfreq(n, 1 / sample_rate)

    # Get the positive frequency components (first half)
    pos_mask = freqs >= 0
    freqs = freqs[pos_mask]
    spectrum = fft_result[pos_mask]
    # Note: this is the amplitude spectrum

    return freqs, spectrum


def plot_waveforms(
    waveform: Waveform, coil_driver: CoilDriver, figsize: tuple[int, int] = (15, 10)
) -> None:
    """Generate and plot waveforms and their FFTs.

    Args:
        waveform: Waveform generator
        coil_driver: Coil driver for calibration
    """
    # Generate a random waveform using standard method
    t, voltage, voltage_spectrum = waveform.sample(random_single_tone=False)

    # Calculate sample rate from time array
    sample_rate = 1 / (t[1] - t[0])

    # Calculate FFT of the voltage waveform
    freqs_fft, voltage_fft = calculate_fft(voltage, sample_rate)

    # Get the displacement and velocity waveforms using the coil driver
    displacement, displacement_spectrum, displacement_freqs = (
        coil_driver.get_displacement(voltage, sample_rate)
    )
    velocity, velocity_spectrum, velocity_freqs = coil_driver.get_velocity(
        voltage, sample_rate
    )

    # Calculate FFTs of displacement and velocity
    _, displacement_fft = calculate_fft(displacement, sample_rate)
    _, velocity_fft = calculate_fft(velocity, sample_rate)

    # Generate a waveform with equalized gain using the new CoilDriver.sample() method
    t_eq, voltage_eq, voltage_spectrum_eq = coil_driver.sample(
        waveform, normalize_gain=True, test_mode=True
    )

    # Calculate FFT of the equalized voltage waveform
    freqs_fft_eq, voltage_fft_eq = calculate_fft(voltage_eq, sample_rate)

    # Get the displacement and velocity waveforms for the equalized voltage
    displacement_eq, displacement_spectrum_eq, displacement_freqs_eq = (
        coil_driver.get_displacement(voltage_eq, sample_rate)
    )
    velocity_eq, velocity_spectrum_eq, velocity_freqs_eq = coil_driver.get_velocity(
        voltage_eq, sample_rate
    )

    # Calculate FFTs of displacement and velocity
    _, displacement_fft_eq = calculate_fft(displacement_eq, sample_rate)
    _, velocity_fft_eq = calculate_fft(velocity_eq, sample_rate)

    # Create a dense frequency array for plotting the analytic transfer functions
    dense_freq = np.linspace(waveform.start_freq, waveform.end_freq, 1000)
    dense_amplitude_transfer = coil_driver._calculate_amplitude_transfer(dense_freq)
    dense_phase_transfer = coil_driver._calculate_phase_transfer(dense_freq)
    displacement_transfer = dense_amplitude_transfer * np.exp(1j * dense_phase_transfer)
    velocity_transfer = displacement_transfer * dense_freq * 2 * np.pi * 1j

    # Create a figure with a 3x2 grid
    fig = plt.figure(figsize=figsize)
    gs = gridspec.GridSpec(3, 2, figure=fig, hspace=0.3, wspace=0.3)

    # Create axes with shared x-axes within columns
    axes = [[None for _ in range(2)] for _ in range(3)]

    # First column (time domain)
    axes[0][0] = fig.add_subplot(gs[0, 0])  # Top row
    axes[1][0] = fig.add_subplot(gs[1, 0], sharex=axes[0][0])  # Middle row
    axes[2][0] = fig.add_subplot(gs[2, 0], sharex=axes[0][0])  # Bottom row

    # Second column (frequency domain)
    axes[0][1] = fig.add_subplot(gs[0, 1])  # Top row
    axes[1][1] = fig.add_subplot(gs[1, 1], sharex=axes[0][1])  # Middle row
    axes[2][1] = fig.add_subplot(gs[2, 1], sharex=axes[0][1])  # Bottom row

    # Hide x-labels for all but the bottom row
    for i in range(2):  # For both columns
        for j in range(2):  # For top and middle rows
            plt.setp(axes[j][i].get_xticklabels(), visible=False)
            axes[j][i].set_xlabel('')

    # Row 1: Voltage
    # Time domain
    ax1 = axes[0][0]
    # ax1.plot(t, voltage, 'b-', label='Standard')
    ax1.plot(t_eq, voltage_eq, 'r--', alpha=0.3, label='Equalized Gain')
    ax1.set_title('Voltage Waveform')
    ax1.set_ylabel('Amplitude (V)')
    ax1.grid(True)
    ax1.legend()

    # Frequency domain - Magnitude
    ax2 = axes[0][1]
    ax2.plot(freqs_fft, np.abs(voltage_fft), 'b--', label='Standard FFT')
    ax2.plot(
        waveform.freq,
        np.abs(voltage_spectrum),
        'b-',
        alpha=0.3,
        label='Standard Spectrum',
    )
    ax2.plot(freqs_fft_eq, np.abs(voltage_fft_eq), 'r--', label='Equalized FFT')
    ax2.plot(
        waveform.freq,
        np.abs(voltage_spectrum_eq),
        'r-',
        alpha=0.3,
        label='Equalized Spectrum',
    )
    ax2.set_title('Voltage Spectrum')
    ax2.set_ylabel('Magnitude')
    ax2.set_xlim(0, waveform.end_freq * 1.2)
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    # Row 2: Displacement
    # Time domain
    ax3 = axes[1][0]
    # ax3.plot(t, displacement, 'b-', label='Standard')
    ax3.plot(t_eq, displacement_eq, 'r--', label='Equalized Gain')
    ax3.set_title('Displacement Waveform')
    ax3.set_ylabel('Displacement (μm)')
    ax3.grid(True)
    ax3.legend()

    # Frequency domain - Magnitude and Phase with twin y-axis
    ax4 = axes[1][1]
    ax4_twin = ax4.twinx()

    # Plot magnitude on left y-axis
    ax4.plot(freqs_fft, np.abs(displacement_fft), 'b--', label='Standard FFT')
    ax4.plot(
        waveform.freq,
        np.abs(displacement_spectrum),
        'b-',
        alpha=0.3,
        label='Standard Expected',
    )
    ax4.plot(
        freqs_fft_eq,
        2 * np.pi * 0.5 * np.abs(displacement_fft_eq),
        'r--',
        label='2π/2*Equalized FFT',
    )
    ax4.plot(
        waveform.freq,
        2 * np.pi * 0.5 * np.abs(displacement_spectrum_eq),
        'r-',
        alpha=0.3,
        label='2π/2*Equalized Expected',
    )

    # Plot transfer function on left y-axis
    ax4.plot(
        dense_freq,
        np.abs(displacement_transfer) / (2 * np.pi) * 2,
        'g-',
        label='Transfer Function (divided by 2π/2)',
    )

    ax4.set_title('Displacement Spectrum & Transfer Function')
    ax4.set_ylabel('Magnitude', color='b')
    ax4.tick_params(axis='y', labelcolor='b')
    ax4.set_xlim(0, waveform.end_freq * 1.2)
    ax4.grid(True, alpha=0.3)

    # Plot phase on right y-axis
    ax4_twin.plot(
        dense_freq,
        np.angle(displacement_transfer),
        'r-',
        alpha=0.3,
        label='Phase Transfer',
    )
    ax4_twin.set_ylabel('Phase (rad)', color='r')
    ax4_twin.tick_params(axis='y', labelcolor='r')
    ax4_twin.set_ylim(-np.pi, np.pi)

    # Create a combined legend
    lines1, labels1 = ax4.get_legend_handles_labels()
    lines2, labels2 = ax4_twin.get_legend_handles_labels()
    ax4.legend(lines1 + lines2, labels1 + labels2, loc='upper right')

    # Row 3: Velocity
    # Time domain
    ax5 = axes[2][0]
    # ax5.plot(t, velocity, 'b-', label='Standard')
    ax5.plot(t_eq, velocity_eq, 'r--', label='Equalized Gain')
    ax5.set_title('Velocity Waveform')
    ax5.set_xlabel('Time (s)')
    ax5.set_ylabel('Velocity (μm/s)')
    ax5.grid(True)
    ax5.legend()

    # Frequency domain - Magnitude and Phase with twin y-axis
    ax6 = axes[2][1]
    ax6_twin = ax6.twinx()

    # Plot magnitude on left y-axis
    ax6.plot(freqs_fft, np.abs(velocity_fft), 'b--', label='Standard FFT')
    ax6.plot(
        waveform.freq,
        np.abs(velocity_spectrum),
        'b-',
        alpha=0.3,
        label='Standard Expected',
    )

    # Calculate FFTs of velocity with equalized gain
    _, velocity_fft_eq = calculate_fft(velocity_eq, sample_rate)
    ax6.plot(
        freqs_fft_eq,
        2 * np.pi * 0.5 * np.abs(velocity_fft_eq),
        'r--',
        label='2π/2*Equalized FFT',
    )
    ax6.plot(
        waveform.freq,
        2 * np.pi * 0.5 * np.abs(velocity_spectrum_eq),
        'r-',
        alpha=0.3,
        label='2π/2*Equalized Expected',
    )

    # For velocity, we do multiply by 2*pi*1j*frequency, angular frequency in FFT
    ax6.plot(
        dense_freq,
        np.abs(velocity_transfer) / (2 * np.pi) * 2,
        'g-',
        label='Transfer Function (divided by 2π/2)',
    )

    ax6.set_title('Velocity Spectrum & Transfer Function')
    ax6.set_xlabel('Frequency (Hz)')
    ax6.set_ylabel('Magnitude', color='b')
    ax6.tick_params(axis='y', labelcolor='b')
    ax6.set_xlim(0, waveform.end_freq * 1.2)
    ax6.grid(True, alpha=0.3)

    # Plot phase on right y-axis
    ax6_twin.plot(
        dense_freq, np.angle(velocity_transfer), 'r-', alpha=0.3, label='Phase Transfer'
    )
    ax6_twin.set_ylabel('Phase (rad)', color='r')
    ax6_twin.tick_params(axis='y', labelcolor='r')
    ax6_twin.set_ylim(-np.pi, np.pi)

    # Create a combined legend
    lines1, labels1 = ax6.get_legend_handles_labels()
    lines2, labels2 = ax6_twin.get_legend_handles_labels()
    ax6.legend(lines1 + lines2, labels1 + labels2, loc='upper right')

    # Set x-labels for bottom row only
    axes[2][0].set_xlabel('Time (s)')
    axes[2][1].set_xlabel('Frequency (Hz)')

    plt.suptitle('Waveform Generation', fontsize=16)
    # Use subplots_adjust instead of tight_layout to avoid warnings
    plt.subplots_adjust(
        left=0.1, right=0.95, top=0.9, bottom=0.1, wspace=0.3, hspace=0.3
    )

    return fig


def plot_waveform_histograms(
    waveform: Waveform, num_samples: int = 100, figsize: tuple[int, int] = (10, 8)
) -> None:
    """Generate multiple waveform samples and plot a histogram of the time-domain values.

    Args:
        waveform: Waveform generator
        num_samples: Number of waveform samples to generate
        figsize: Figure size (width, height) in inches
    """
    # Initialize array to store all voltage samples
    all_voltages = []

    # Generate multiple waveform samples
    for i in range(num_samples):
        # Generate a random waveform with phase randomization only
        # The spectrum amplitudes are kept the same
        t, voltage, voltage_spectrum = waveform.sample(randomize_phase_only=True)

        # Store the time-domain voltage values
        all_voltages.extend(voltage)

    # Compute variance for the noise distribution
    noise_variance = (
        np.sum(np.abs(voltage_spectrum) ** 2)
        * len(t)
        * (t[1] - t[0]) ** 2
        / np.max(t)
        * (waveform.freq[1] - waveform.freq[0])
    )
    # We use norm="ortho" in the FFT, so we need to multiply the PSD by the number of samples
    # Then, the PSD is approximated by multiplying py abs(\Delta t)**2/T
    # For the integral to get the total variance we multiply by the size of the frequency bin

    # Convert to numpy array
    all_voltages = np.array(all_voltages)

    # Create a figure
    fig, ax = plt.subplots(figsize=figsize)

    # Plot histogram of time-domain voltage values with proper normalization
    hist_values, bin_edges, _ = ax.hist(
        all_voltages, bins=500, alpha=0.7, color='blue', density=True
    )
    ax.set_title('Histogram of Time-Domain Voltage Values')
    ax.set_xlabel('Voltage (V)')
    ax.set_ylabel('Probability Density')
    ax.grid(True, alpha=0.3)

    # Overlay Gaussian with zero mean and computed variance (already normalized)
    x = np.linspace(min(all_voltages), max(all_voltages), 1000)
    gaussian = stats.norm.pdf(x, loc=0, scale=np.sqrt(noise_variance))
    ax.plot(
        x, gaussian, 'r-', linewidth=2, label=f'Gaussian (μ=0, σ²={noise_variance:.4f})'
    )
    ax.legend()

    plt.suptitle('Waveform Sample Statistics', fontsize=16)
    plt.tight_layout(
        rect=[0, 0, 1, 0.95]
    )  # Adjust layout while preserving space for the title

    return fig


if __name__ == '__main__':
    # Create a waveform generator
    waveform = Waveform(start_freq=1, end_freq=1000, gen_dec=8192, acq_dec=256)

    # Create a coil driver with default calibration parameters
    coil_driver = CoilDriver()

    # Generate and plot waveforms
    fig1 = plot_waveforms(waveform, coil_driver)

    # Generate and plot waveform histograms
    fig2 = plot_waveform_histograms(waveform, num_samples=100)

    # Show the plots
    plt.show()
