#!/usr/bin/env python3
"""
Plot Waveforms - A script for visualizing waveforms generated by the Waveform class
and processed by the CoilDriver class.

This script generates random waveforms, applies calibration to get displacement and velocity,
and plots all waveforms and their FFTs.
"""

import numpy as np
import matplotlib.pyplot as plt
from numpy.fft import fft, fftfreq
from typing import Tuple
import matplotlib.gridspec as gridspec

from redpitaya.waveform import Waveform
from redpitaya.coil_driver import CoilDriver


def calculate_fft(signal: np.ndarray, sample_rate: float) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Calculate the FFT of a signal.
    
    Args:
        signal: Time domain signal
        sample_rate: Sample rate in Hz
        
    Returns:
        Tuple containing:
        - Frequencies
        - Magnitude of FFT
        - Phase of FFT
    """
    n = len(signal)
    fft_result = fft(signal, norm="ortho")
    freqs = fftfreq(n, 1/sample_rate)
    
    # Get the positive frequency components (first half)
    pos_mask = freqs >= 0
    freqs = freqs[pos_mask]
    fft_result = fft_result[pos_mask]
    
    magnitude = np.abs(fft_result)
    phase = np.angle(fft_result)
    
    return freqs, magnitude, phase


def plot_waveforms(
    waveform: Waveform,
    coil_driver: CoilDriver,
    start_freq: float = 10,
    end_freq: float = 1000,
    figsize: Tuple[int, int] = (15, 10)
) -> None:
    """
    Generate and plot waveforms and their FFTs.
    
    Args:
        waveform: Waveform generator
        coil_driver: Coil driver for calibration
        start_freq: Start frequency in Hz
        end_freq: End frequency in Hz
        figsize: Figure size (width, height) in inches
    """
    # Update frequency range
    waveform.set_frequency_range(start_freq, end_freq)
    
    # Generate a random waveform
    t, voltage, voltage_spectral_mod, voltage_spectral_phase = waveform.sample()
    voltage_spectrum = voltage_spectral_mod * np.exp(1j * 2*np.pi*voltage_spectral_phase)
    
    # Calculate sample rate from time array
    sample_rate = 1 / (t[1] - t[0])
    
    # Calculate FFT of the voltage waveform
    freqs_fft, voltage_mag, voltage_phase = calculate_fft(voltage, sample_rate)
    
    # Get the displacement and velocity waveforms using the coil driver
    displacement, displacement_spectrum, displacement_freqs = coil_driver.get_displacement(voltage, sample_rate)
    velocity, velocity_spectrum, velocity_freqs = coil_driver.get_velocity(voltage, sample_rate)
    
    # Calculate FFTs of displacement and velocity
    _, displacement_mag, displacement_phase = calculate_fft(displacement, sample_rate)
    _, velocity_mag, velocity_phase = calculate_fft(velocity, sample_rate)
    
    # Calculate expected displacement and velocity spectra from the original spectrum
    # Get the amplitude transfer functions
    amplitude_transfer = coil_driver._calculate_amplitude_transfer(np.abs(waveform.freq))
    # For negative frequencies, we need to conjugate the phase
    phase_transfer = np.where(
        waveform.freq < 0,
        np.exp(-1j * coil_driver._calculate_phase_transfer(-waveform.freq)),
        np.exp(1j * coil_driver._calculate_phase_transfer(waveform.freq))
    )
    
    # Apply transfer functions to the original spectrum
    expected_displacement_spectrum = voltage_spectrum * amplitude_transfer * phase_transfer
    expected_displacement_spectral_mod = np.abs(expected_displacement_spectrum)
    expected_velocity_spectrum = voltage_spectrum * amplitude_transfer * phase_transfer * waveform.freq * 2 * np.pi*1j
    expected_velocity_spectral_mod = np.abs(expected_velocity_spectrum)
    
    # Create a dense frequency array for plotting the analytic transfer functions
    dense_freq = np.linspace(start_freq, end_freq, 1000)
    dense_amplitude_transfer = coil_driver._calculate_amplitude_transfer(dense_freq)
    dense_phase_transfer = coil_driver._calculate_phase_transfer(dense_freq)
    displacement_transfer = dense_amplitude_transfer * np.exp(1j * 2*np.pi* dense_phase_transfer)
    velocity_transfer = displacement_transfer * dense_freq * 2 * np.pi * 1j
    displacement_transfer_mod = np.abs(displacement_transfer)
    displacement_transfer_phase = np.angle(displacement_transfer)
    velocity_transfer_mod = np.abs(velocity_transfer)
    velocity_transfer_phase = np.angle(velocity_transfer)
    
    # Create a figure with a 3x2 grid
    fig = plt.figure(figsize=figsize)
    gs = gridspec.GridSpec(3, 2, figure=fig, hspace=0.3, wspace=0.3)
    
    # Create axes with shared x-axes within columns
    axes = [[None for _ in range(2)] for _ in range(3)]
    
    # First column (time domain)
    axes[0][0] = fig.add_subplot(gs[0, 0])  # Top row
    axes[1][0] = fig.add_subplot(gs[1, 0], sharex=axes[0][0])  # Middle row
    axes[2][0] = fig.add_subplot(gs[2, 0], sharex=axes[0][0])  # Bottom row
    
    # Second column (frequency domain)
    axes[0][1] = fig.add_subplot(gs[0, 1])  # Top row
    axes[1][1] = fig.add_subplot(gs[1, 1], sharex=axes[0][1])  # Middle row
    axes[2][1] = fig.add_subplot(gs[2, 1], sharex=axes[0][1])  # Bottom row
    
    # Hide x-labels for all but the bottom row
    for i in range(2):  # For both columns
        for j in range(2):  # For top and middle rows
            plt.setp(axes[j][i].get_xticklabels(), visible=False)
            axes[j][i].set_xlabel('')
    
    # Row 1: Voltage
    # Time domain
    ax1 = axes[0][0]
    ax1.plot(t, voltage)
    ax1.set_title('Voltage Waveform')
    ax1.set_ylabel('Amplitude (V)')
    ax1.grid(True)
    
    # Frequency domain - Magnitude
    ax2 = axes[0][1]
    ax2.plot(freqs_fft, voltage_mag, 'b--', label='FFT Magnitude')
    ax2.plot(waveform.freq, voltage_spectral_mod, 'b-', alpha=0.3, label='Original Spectrum')
    ax2.set_title('Voltage Spectrum')
    ax2.set_ylabel('Magnitude')
    ax2.set_xlim(0, end_freq * 1.2)
    ax2.grid(True, alpha=0.3)
    ax2.legend()
    
    # Row 2: Displacement
    # Time domain
    ax3 = axes[1][0]
    ax3.plot(t, displacement)
    ax3.set_title('Displacement Waveform')
    ax3.set_ylabel('Displacement (μm)')
    ax3.grid(True)
    
    # Frequency domain - Magnitude and Phase with twin y-axis
    ax4 = axes[1][1]
    ax4_twin = ax4.twinx()
    
    # Plot magnitude on left y-axis
    ax4.plot(freqs_fft, displacement_mag, 'b--', label='FFT Magnitude')
    ax4.plot(waveform.freq, expected_displacement_spectral_mod, 'b-', alpha=0.3, label='Expected Spectrum')
    
    # Plot transfer function on left y-axis
    ax4.plot(dense_freq, displacement_transfer_mod, 'g-', label='Transfer Function')
    
    ax4.set_title('Displacement Spectrum & Transfer Function')
    ax4.set_ylabel('Magnitude', color='b')
    ax4.tick_params(axis='y', labelcolor='b')
    ax4.set_xlim(0, end_freq * 1.2)
    ax4.grid(True, alpha=0.3)
    
    # Plot phase on right y-axis
    ax4_twin.plot(dense_freq, displacement_transfer_phase, 'r-', alpha=0.3, label='Phase Transfer')
    ax4_twin.set_ylabel('Phase (rad)', color='r')
    ax4_twin.tick_params(axis='y', labelcolor='r')
    ax4_twin.set_ylim(-np.pi, np.pi)
    
    # Create a combined legend
    lines1, labels1 = ax4.get_legend_handles_labels()
    lines2, labels2 = ax4_twin.get_legend_handles_labels()
    ax4.legend(lines1 + lines2, labels1 + labels2, loc='upper right')
    
    # Row 3: Velocity
    # Time domain
    ax5 = axes[2][0]
    ax5.plot(t, velocity)
    ax5.set_title('Velocity Waveform')
    ax5.set_xlabel('Time (s)')
    ax5.set_ylabel('Velocity (μm/s)')
    ax5.grid(True)
    
    # Frequency domain - Magnitude and Phase with twin y-axis
    ax6 = axes[2][1]
    ax6_twin = ax6.twinx()
    
    # Plot magnitude on left y-axis
    ax6.plot(freqs_fft, velocity_mag, 'b--', label='FFT Magnitude')
    ax6.plot(waveform.freq, expected_velocity_spectral_mod, 'b-', alpha=0.3, label='Expected Spectrum')
    
    # For velocity, we do multiply by 2*pi*1j*frequency, angular frequency in FFT
    ax6.plot(dense_freq, velocity_transfer_mod, 'g-', label='Transfer Function')
    
    ax6.set_title('Velocity Spectrum & Transfer Function')
    ax6.set_xlabel('Frequency (Hz)')
    ax6.set_ylabel('Magnitude', color='b')
    ax6.tick_params(axis='y', labelcolor='b')
    ax6.set_xlim(0, end_freq * 1.2)
    ax6.grid(True, alpha=0.3)
    
    # Plot phase on right y-axis
    ax6_twin.plot(dense_freq, velocity_transfer_phase, 'r-', alpha=0.3, label='Phase Transfer')
    ax6_twin.set_ylabel('Phase (rad)', color='r')
    ax6_twin.tick_params(axis='y', labelcolor='r')
    ax6_twin.set_ylim(-np.pi, np.pi)
    
    # Create a combined legend
    lines1, labels1 = ax6.get_legend_handles_labels()
    lines2, labels2 = ax6_twin.get_legend_handles_labels()
    ax6.legend(lines1 + lines2, labels1 + labels2, loc='upper right')
    
    # Set x-labels for bottom row only
    axes[2][0].set_xlabel('Time (s)')
    axes[2][1].set_xlabel('Frequency (Hz)')
    
    plt.suptitle('Waveform Generation', fontsize=16)
    plt.tight_layout()
    
    return fig


if __name__ == "__main__":
    # Create a waveform generator
    waveform = Waveform(
        start_freq=1,
        end_freq=1000,
        gen_dec=8192,
        acq_dec=256
    )
    
    # Create a coil driver with default calibration parameters
    coil_driver = CoilDriver()
    
    # Generate and plot waveforms
    fig = plot_waveforms(waveform, coil_driver)
    
    # Show the plot
    plt.show()
